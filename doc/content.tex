\section{Постановка задачи}

Алгоритм А* (A-star).

Проанализировать поставленную задачу, реализовать последовательный
алгоритм ее решения, при необходимости вспомнить соответствующие
дисциплины. Выделить подзадачи, которые могут быть вычислены
параллельно и реализованы в виде потоков с барьерной(fork-join)
синхронизацией.

\section{Последовательный алгоритм}

\begin{center}
  \begin{tabular}{|L{18cm}|}
    \hline
    \textbf{Input:} Поле $Map$ c размеченными проходимыми и не проходимыми вершинами \\
    \textbf{Init:}
    $Start, Target$ \\
    $Open, Closed$ \\
    \itshape{\textbf{push} $Start \rightarrow Open$} \\
    \textbf{while} $open$ содержит элементы и путь не найден \\
    \textbf{do} \\
    \tabitem Удаляем из $Open$ узел
    $Current = min_F(Open)$ \\
    \tabitem \itshape{\textbf{push} $Current \rightarrow Closed$} \\
    \tabitem Для каждой из восьми смежных($Adj$) вершин:\\

    Если вершина $Adj$ проходима и не в $Closed$:\\
    \tabitem Если вершина не в $Open$: \\
    \hspace{0.5cm} \tabitem $Adj.Parrent = Current;$ \\
    \hspace{0.5cm} \tabitem Пересчитать $F, G, H$ \\
    \hspace{0.5cm} \tabitem \textbf{push} $ Adj \rightarrow Open$ \\
    \tabitem Если вершина в $Open$: \\
    \hspace{0.5cm} \tabitem Пересчитать $F, G$.
    Если новое $G$ меньше старого, поменять $Parent$ \\
    \tabitem Если $target$ в $open$, путь найден. \\
    \textbf{end.} \\
    \hline
  \end{tabular}
\end{center}

\section{Параллельный алгоритм}

\subsection{Разбиение на кластеры}
Метод заключается в разбиении карты на кластеры и нахождение всех
точек входа и выхода в каждом из них. Чтобы добиться эффективности, необходимо
запускать программу на многоядерном устройстве (например, на видеокарте
с поддержкой технологии \textit{CUDA}). Но зато такой алгоритм лучше
всего подходит для нахождения всех путей на поле.

\subsection{Простой параллельный алгоритм}
Единственная возможность применить к алгоритму барьерную синхронизацию
-- это заменить цикл по восьми смежным вершинам параллельной секцией,
равномерно распределив обработку вершин по потокам. Этот метод выглядит логичным, однако
на практике не приносит результатов, на что есть несколько причин.

Во-первых, передача сообщений между потоками -- очень дорогая операция.
Во-вторых, к потокам неприменимы оптимизации компилятора. Поэтому барьерная
синхронизация целесообразна только в случае обработки больших данных,
но не восьми ячеек.

Таким образом, было решено использовать использовать немодифицированный
последовательный алгоритм для нахождения всех путей на поле, разделяя между
отдельными потоками вычисление каждого пути.

\section{Вычислительная сложность}

Временная сложность алгоритма A* зависит от эвристики. В худшем
случае, число вершин, исследуемых алгоритмом, растёт экспоненциально
по сравнению с длиной оптимального пути, но сложность становится
полиномиальной, когда эвристика удовлетворяет следующему условию:

\begin{center}
$|h(x)−h^*(x)| \leq O(\log h^*(x))$
\end{center}

где $h^*$ -- оптимальная эвристика,
то есть точная оценка расстояния из вершины $x$ к цели. Другими словами,
ошибка $h(x)$ не должна расти быстрее, чем логарифм от оптимальной
эвристики.

Но ещё большую проблему, чем временная сложность, представляют собой
потребляемые алгоритмом ресурсы памяти. В худшем случае ему приходится
помнить экспоненциальное количество узлов. Для борьбы с этим было
предложено несколько вариаций алгоритма, таких как алгоритм A* с
итеративным углублением (iterative deeping A*, IDA*), A* с
ограничением памяти (memory-bounded A*, MA*), упрощённый MA*
(simplified MA*, SMA*) и рекурсивный поиск по первому наилучшему
совпадению (recursive best-first search, RBFS).

\section{Результаты тестов производительности}
% тут табличка с тестами и их временем.
\begin{center}
  \begin{tabular}{|c|c|c|c|}
    \hline

    Тест & Результат & Время, c \\
    \hline
    
    16x16-multi & T & 40.33 \\
    16x16-single & T & 90.46 \\
    10x10-multi & T & 0.74 \\
    10x10-multi & T & 1.53 \\

    \hline
  \end{tabular}
\end{center}

